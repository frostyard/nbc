---
phase: 01-testing-reliability
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - pkg/incus_test.go
  - Makefile
autonomous: true

must_haves:
  truths:
    - "First VM test runs using Go test infrastructure"
    - "Test uses IncusFixture for VM management"
    - "Test cleans up resources on success and failure"
    - "make test-incus-go target runs Go-based VM tests"
  artifacts:
    - path: "pkg/incus_test.go"
      provides: "Go-based Incus VM integration tests"
      exports: ["TestIncus_Install"]
      min_lines: 100
    - path: "Makefile"
      provides: "test-incus-go target"
      contains: "test-incus-go"
  key_links:
    - from: "pkg/incus_test.go"
      to: "pkg/testutil/incus.go"
      via: "NewIncusFixture"
      pattern: "testutil\\.NewIncusFixture"
    - from: "pkg/incus_test.go"
      to: "context.WithTimeout"
      via: "TimeoutVM constant"
      pattern: "context\\.WithTimeout.*TimeoutVM"
---

<objective>
Migrate the first VM test (install test) from bash to Go, validating the test infrastructure works end-to-end.

Purpose: Prove the fixture-based approach works before migrating all tests. One working test validates the entire infrastructure.
Output: pkg/incus_test.go with TestIncus_Install, Makefile with test-incus-go target.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-testing-reliability/01-RESEARCH.md
@.planning/phases/01-testing-reliability/01-CONTEXT.md
@pkg/testutil/incus.go
@pkg/testutil/cleanup.go
@pkg/testutil/timeouts.go
@test_incus_quick.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create first Go-based VM test</name>
  <files>pkg/incus_test.go</files>
  <action>
Create `pkg/incus_test.go` with the install test migrated from test_incus_quick.sh:

```go
package pkg

import (
    "context"
    "os"
    "testing"
    
    "github.com/frostyard/nbc/pkg/testutil"
)

// TestMain provides clean slate for VM tests
func TestMain(m *testing.M) {
    // Clean any orphaned resources from previous runs
    _ = testutil.CleanupAllNbcTestResources()
    code := m.Run()
    // Final cleanup
    _ = testutil.CleanupAllNbcTestResources()
    os.Exit(code)
}

// TestIncus_Install tests nbc installation in a VM
// This is the primary integration test validating:
// - Partition creation (4 partitions)
// - Filesystem formatting
// - Container extraction
// - Bootloader installation
// - /etc overlay setup
func TestIncus_Install(t *testing.T) {
    testutil.RequireRoot(t)
    testutil.RequireTools(t, "incus")
    
    ctx, cancel := context.WithTimeout(context.Background(), testutil.TimeoutVM)
    defer cancel()
    
    // Create fixture (cleanup registered automatically)
    fixture := testutil.NewIncusFixture(t)
    
    // Create VM with Fedora image
    if err := fixture.CreateVM("images:fedora/42/cloud"); err != nil {
        t.Fatalf("Failed to create VM: %v", err)
    }
    
    // Wait for VM to be ready
    if err := fixture.WaitForReady(ctx); err != nil {
        fixture.DumpDiagnostics("VM boot failed")
        t.Fatalf("VM not ready: %v", err)
    }
    
    // Create baseline snapshot for potential reset
    if err := fixture.CreateBaselineSnapshot("baseline"); err != nil {
        t.Fatalf("Failed to create baseline snapshot: %v", err)
    }
    
    // Attach test disk (60GB)
    if err := fixture.AttachDisk("test-disk", "60GB"); err != nil {
        t.Fatalf("Failed to attach disk: %v", err)
    }
    
    // Install required tools
    _, err := fixture.ExecCommand("dnf", "install", "-y", "-q",
        "gdisk", "util-linux", "e2fsprogs", "dosfstools", "parted", "rsync", "btrfs-progs")
    if err != nil {
        t.Fatalf("Failed to install tools: %v", err)
    }
    
    // Build and push nbc binary
    // (assumes binary built externally, or build here)
    if err := fixture.PushFile("./nbc", "/usr/local/bin/nbc"); err != nil {
        t.Fatalf("Failed to push nbc: %v", err)
    }
    _, _ = fixture.ExecCommand("chmod", "+x", "/usr/local/bin/nbc")
    
    // Find test disk
    diskOutput, err := fixture.ExecCommand("bash", "-c", `
        for disk in $(lsblk -ndo NAME,TYPE | grep disk | awk '{print $1}'); do
            if ! lsblk -no NAME /dev/$disk | grep -q '[0-9]'; then
                echo "/dev/$disk"
                exit 0
            fi
        done
    `)
    if err != nil || diskOutput == "" {
        t.Fatalf("Failed to find test disk: %v", err)
    }
    testDisk := strings.TrimSpace(diskOutput)
    t.Logf("Test disk: %s", testDisk)
    
    // Run nbc install
    testImage := os.Getenv("TEST_IMAGE")
    if testImage == "" {
        testImage = "ghcr.io/frostyard/snow:latest"
    }
    
    installOutput, err := fixture.ExecCommand("bash", "-c", 
        fmt.Sprintf("echo 'yes' | nbc install --image '%s' --device '%s' --verbose", 
            testImage, testDisk))
    if err != nil {
        fixture.DumpDiagnostics("nbc install failed")
        t.Fatalf("nbc install failed: %v\nOutput: %s", err, installOutput)
    }
    t.Logf("Install completed")
    
    // Verify partition count
    partOutput, _ := fixture.ExecCommand("lsblk", "-n", testDisk)
    partCount := strings.Count(partOutput, "part")
    if partCount != 4 {
        t.Errorf("Expected 4 partitions, got %d", partCount)
    }
    
    // Verify key files exist
    verifyOutput, err := fixture.ExecCommand("bash", "-c", fmt.Sprintf(`
        ROOT=$(lsblk -nlo NAME,PARTLABEL %s | grep root1 | awk '{print "/dev/"$1}')
        VAR=$(lsblk -nlo NAME,PARTLABEL %s | grep var | awk '{print "/dev/"$1}')
        mkdir -p /mnt/check /mnt/check-var
        mount $ROOT /mnt/check
        mount $VAR /mnt/check-var
        
        # Check config exists
        [ -f /mnt/check-var/lib/nbc/state/config.json ] && echo "config:ok" || echo "config:missing"
        
        # Check dracut module
        [ -d /mnt/check/usr/lib/dracut/modules.d/95etc-overlay ] && echo "dracut:ok" || echo "dracut:missing"
        
        # Check .etc.lower
        [ -d /mnt/check/.etc.lower ] && echo "etclower:ok" || echo "etclower:missing"
        
        umount /mnt/check-var
        umount /mnt/check
        rmdir /mnt/check /mnt/check-var
    `, testDisk, testDisk))
    if err != nil {
        fixture.DumpDiagnostics("verification failed")
        t.Fatalf("Verification failed: %v", err)
    }
    
    if !strings.Contains(verifyOutput, "config:ok") {
        t.Error("Config file not found in /var/lib/nbc/state/")
    }
    if !strings.Contains(verifyOutput, "dracut:ok") {
        t.Error("Dracut etc-overlay module not found")
    }
    if !strings.Contains(verifyOutput, "etclower:ok") {
        t.Error(".etc.lower directory not found")
    }
    
    t.Log("Install test passed")
}
```

Note: Add necessary imports (strings, fmt, os). The test follows the pattern from test_incus_quick.sh but uses structured Go infrastructure.
  </action>
  <verify>
```bash
go build ./pkg/...
```
Build should succeed (tests compile).
  </verify>
  <done>pkg/incus_test.go compiles with TestIncus_Install test</done>
</task>

<task type="auto">
  <name>Task 2: Add Makefile target for Go-based VM tests</name>
  <files>Makefile</files>
  <action>
Add a new Makefile target for running Go-based Incus tests:

```makefile
test-incus-go: build ## Run Go-based Incus VM integration tests
	@echo "Running Go-based Incus integration tests (requires root and incus)..."
	@if [ "$$(id -u)" -ne 0 ]; then \
		echo "Re-running with sudo..."; \
		sudo -E env "PATH=$$PATH:/usr/sbin:/sbin" $(MAKE) _test-incus-go; \
	else \
		$(MAKE) _test-incus-go; \
	fi

_test-incus-go: ## Internal target for Go Incus tests
	@go test -v ./pkg/... -run "^TestIncus_" -timeout 30m
```

This target:
- Requires root (like existing test-incus)
- Runs only TestIncus_* tests
- Has 30-minute overall timeout
- Builds nbc first (needed for pushing to VM)
  </action>
  <verify>
```bash
grep -q "test-incus-go" Makefile && echo "Found" || echo "Not found"
```
Should output "Found".
  </verify>
  <done>Makefile has test-incus-go target that runs Go-based VM tests</done>
</task>

</tasks>

<verification>
1. `go build ./pkg/...` succeeds
2. `make test-incus-go` target exists
3. TestIncus_Install uses IncusFixture, context timeout, diagnostics on failure
4. Test cleans up via fixture.Cleanup (registered in NewIncusFixture)
</verification>

<success_criteria>
- TestIncus_Install compiles and follows patterns from RESEARCH.md
- Test validates: 4 partitions, config file, dracut module, .etc.lower
- Cleanup happens automatically via t.Cleanup
- Failure triggers DumpDiagnostics
- Makefile provides test-incus-go target
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-reliability/01-04-SUMMARY.md`
</output>
